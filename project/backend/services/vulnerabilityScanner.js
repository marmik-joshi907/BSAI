import logger from '../utils/logger.js';

// Vulnerability patterns and rules
const vulnerabilityPatterns = {
  // SQL Injection patterns
  sqlInjection: [
    {
      pattern: /\$_(?:GET|POST|REQUEST)\s*\[\s*['"]\w+['"]\s*\]\s*(?:(?:\.|\+)\s*)?(?:(?:"|')\s*(?:SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER)\s*(?:"|')?|(?:SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER))/gi,
      severity: 'Critical',
      description: 'Direct user input is used in SQL query without sanitization',
      suggestion: 'Use prepared statements or parameterized queries to prevent SQL injection',
      fixedCode: '$stmt = $pdo->prepare("SELECT * FROM users WHERE id = ?");\n$stmt->execute([$_GET[\'id\']]);'
    },
    {
      pattern: /query\s*\(\s*["`'].*?\$\{.*?\}.*?["`']\s*\)/gi,
      severity: 'Critical',
      description: 'Template literal used in SQL query with user input',
      suggestion: 'Use parameterized queries instead of string interpolation',
      fixedCode: 'const result = await db.query("SELECT * FROM users WHERE id = $1", [userId]);'
    },
    {
      pattern: /execute\s*\(\s*["`'].*?\+.*?["`']\s*\)/gi,
      severity: 'High',
      description: 'String concatenation used in SQL query',
      suggestion: 'Use parameterized queries to prevent SQL injection',
      fixedCode: 'cursor.execute("SELECT * FROM users WHERE name = %s", (username,))'
    }
  ],

  // Cross-Site Scripting (XSS) patterns
  xss: [
    {
      pattern: /innerHTML\s*=\s*.*?(?:\+|`\$\{).*?(?:\+|`)/gi,
      severity: 'High',
      description: 'User input directly inserted into innerHTML without sanitization',
      suggestion: 'Use textContent or sanitize HTML content before insertion',
      fixedCode: 'element.textContent = userInput; // or use DOMPurify.sanitize(userInput)'
    },
    {
      pattern: /document\.write\s*\(\s*.*?(?:\+|`\$\{).*?(?:\+|`)/gi,
      severity: 'High',
      description: 'User input used in document.write without sanitization',
      suggestion: 'Avoid document.write and use safe DOM manipulation methods',
      fixedCode: 'const safeElement = document.createElement("div");\nsafeElement.textContent = userInput;'
    },
    {
      pattern: /echo\s+.*?\$_(?:GET|POST|REQUEST)/gi,
      severity: 'High',
      description: 'User input echoed directly without encoding',
      suggestion: 'Use htmlspecialchars() or similar encoding functions',
      fixedCode: 'echo htmlspecialchars($_GET[\'input\'], ENT_QUOTES, \'UTF-8\');'
    }
  ],

  // Hardcoded secrets patterns
  hardcodedSecrets: [
    {
      pattern: /(?:api[_-]?key|secret[_-]?key|password|token)\s*[:=]\s*["`'][a-zA-Z0-9+/=]{8,}["`']/gi,
      severity: 'High',
      description: 'Hardcoded API key or secret found in source code',
      suggestion: 'Store secrets in environment variables or secure configuration files',
      fixedCode: 'const apiKey = process.env.API_KEY || "";'
    },
    {
      pattern: /["`'](?:sk-|pk_|rk_)[a-zA-Z0-9]{20,}["`']/gi,
      severity: 'Critical',
      description: 'Hardcoded API key with recognizable prefix found',
      suggestion: 'Remove hardcoded keys and use environment variables',
      fixedCode: 'const stripeKey = process.env.STRIPE_SECRET_KEY;'
    },
    {
      pattern: /(?:password|pwd)\s*[:=]\s*["\`'][^"\`'\s]{6,}["\`']/gi,
      severity: 'High',
      description: 'Hardcoded password found in source code',
      suggestion: 'Use secure password storage and environment variables',
      fixedCode: 'const password = process.env.DB_PASSWORD;'
    }
  ],

  // Insecure authentication patterns
  insecureAuth: [
    {
      pattern: /md5\s*\(\s*.*?password.*?\)/gi,
      severity: 'High',
      description: 'MD5 used for password hashing - cryptographically insecure',
      suggestion: 'Use bcrypt, scrypt, or Argon2 for password hashing',
      fixedCode: 'const hashedPassword = await bcrypt.hash(password, 12);'
    },
    {
      pattern: /sha1\s*\(\s*.*?password.*?\)/gi,
      severity: 'Medium',
      description: 'SHA1 used for password hashing - not recommended',
      suggestion: 'Use bcrypt, scrypt, or Argon2 for password hashing',
      fixedCode: 'const hashedPassword = await bcrypt.hash(password, 12);'
    },
    {
      pattern: /password\s*==\s*["`'].*?["`']/gi,
      severity: 'Critical',
      description: 'Plain text password comparison detected',
      suggestion: 'Use secure password hashing and comparison',
      fixedCode: 'const isValid = await bcrypt.compare(inputPassword, hashedPassword);'
    }
  ],

  // Path traversal patterns
  pathTraversal: [
    {
      pattern: /(?:include|require|file_get_contents|fopen)\s*\(\s*.*?\$_(?:GET|POST|REQUEST).*?\)/gi,
      severity: 'Critical',
      description: 'File inclusion with user input - potential path traversal',
      suggestion: 'Validate and sanitize file paths, use whitelist of allowed files',
      fixedCode: 'if (in_array($file, $allowedFiles)) { include($file); }'
    },
    {
      pattern: /\.\.\/|\.\.\\\/gi,
      severity: 'Medium',
      description: 'Potential path traversal sequence detected',
      suggestion: 'Validate file paths and prevent directory traversal',
      fixedCode: 'const safePath = path.resolve(baseDir, userInput);'
    }
  ],

  // CSRF patterns
  csrf: [
    {
      pattern: /<form[^>]*method\s*=\s*["`']post["`'][^>]*>(?![\s\S]*csrf)/gi,
      severity: 'Medium',
      description: 'POST form without CSRF protection detected',
      suggestion: 'Add CSRF tokens to all state-changing forms',
      fixedCode: '<input type="hidden" name="csrf_token" value="<?php echo $_SESSION[\'csrf_token\']; ?>">'
    }
  ],

  // Insecure random patterns
  insecureRandom: [
    {
      pattern: /Math\.random\(\)/gi,
      severity: 'Low',
      description: 'Math.random() is not cryptographically secure',
      suggestion: 'Use crypto.getRandomValues() for security-sensitive random numbers',
      fixedCode: 'const randomArray = new Uint32Array(1);\ncrypto.getRandomValues(randomArray);'
    },
    {
      pattern: /rand\(\)|mt_rand\(\)/gi,
      severity: 'Low',
      description: 'PHP rand() or mt_rand() are not cryptographically secure',
      suggestion: 'Use random_bytes() or random_int() for cryptographic purposes',
      fixedCode: '$secureRandom = random_int(1000000, 9999999);'
    }
  ]
};

// Main scanning function
export const scanCode = async (code, filename = 'unknown') => {
  const vulnerabilities = [];
  const lines = code.split('\n');

  logger.info(`Scanning ${filename} (${lines.length} lines)`);

  // Scan for each vulnerability type
  for (const [vulnType, patterns] of Object.entries(vulnerabilityPatterns)) {
    for (const pattern of patterns) {
      const matches = [...code.matchAll(pattern.pattern)];
      
      for (const match of matches) {
        // Find the line number
        const beforeMatch = code.substring(0, match.index);
        const lineNumber = beforeMatch.split('\n').length;
        
        // Get the actual line content
        const lineContent = lines[lineNumber - 1]?.trim() || match[0];

        vulnerabilities.push({
          type: getVulnerabilityTypeName(vulnType),
          severity: pattern.severity,
          line: lineNumber,
          description: pattern.description,
          code: lineContent,
          suggestion: pattern.suggestion,
          fixedCode: pattern.fixedCode,
          match: match[0]
        });
      }
    }
  }

  // Additional context-aware checks
  const contextualVulns = performContextualAnalysis(code, filename, lines);
  vulnerabilities.push(...contextualVulns);

  logger.info(`Found ${vulnerabilities.length} vulnerabilities in ${filename}`);
  return vulnerabilities;
};

// Helper function to get human-readable vulnerability type names
const getVulnerabilityTypeName = (vulnType) => {
  const typeNames = {
    sqlInjection: 'SQL Injection',
    xss: 'Cross-Site Scripting (XSS)',
    hardcodedSecrets: 'Hardcoded Secret',
    insecureAuth: 'Insecure Authentication',
    pathTraversal: 'Path Traversal',
    csrf: 'CSRF Vulnerability',
    insecureRandom: 'Insecure Random Number Generation'
  };
  return typeNames[vulnType] || vulnType;
};

// Perform additional contextual analysis
const performContextualAnalysis = (code, filename, lines) => {
  const vulnerabilities = [];

  // Check for missing security headers in web files
  if (filename.endsWith('.html') || filename.endsWith('.htm')) {
    if (!code.includes('Content-Security-Policy') && !code.includes('X-Frame-Options')) {
      vulnerabilities.push({
        type: 'Missing Security Headers',
        severity: 'Medium',
        line: 1,
        description: 'HTML file missing important security headers',
        code: '<head>',
        suggestion: 'Add Content-Security-Policy and X-Frame-Options headers',
        fixedCode: '<meta http-equiv="Content-Security-Policy" content="default-src \'self\'">\n<meta http-equiv="X-Frame-Options" content="DENY">'
      });
    }
  }

  // Check for eval usage
  const evalPattern = /eval\s*\(/gi;
  const evalMatches = [...code.matchAll(evalPattern)];
  for (const match of evalMatches) {
    const beforeMatch = code.substring(0, match.index);
    const lineNumber = beforeMatch.split('\n').length;
    const lineContent = lines[lineNumber - 1]?.trim() || match[0];

    vulnerabilities.push({
      type: 'Code Injection',
      severity: 'Critical',
      line: lineNumber,
      description: 'Use of eval() can lead to code injection vulnerabilities',
      code: lineContent,
      suggestion: 'Avoid using eval(). Use JSON.parse() for JSON data or other safe alternatives',
      fixedCode: 'const data = JSON.parse(jsonString); // Instead of eval()'
    });
  }

  // Check for console.log in production code
  const consolePattern = /console\.log\s*\(/gi;
  const consoleMatches = [...code.matchAll(consolePattern)];
  if (consoleMatches.length > 3) { // Only flag if there are many console.log statements
    vulnerabilities.push({
      type: 'Information Disclosure',
      severity: 'Low',
      line: 1,
      description: 'Multiple console.log statements may leak sensitive information',
      code: 'console.log(...)',
      suggestion: 'Remove or replace console.log statements with proper logging in production',
      fixedCode: '// Use a proper logging library instead of console.log'
    });
  }

  return vulnerabilities;
};

// Export additional utility functions
export const getSeverityScore = (severity) => {
  const scores = {
    'Critical': 10,
    'High': 7,
    'Medium': 4,
    'Low': 1
  };
  return scores[severity] || 0;
};

export const calculateRiskScore = (vulnerabilities) => {
  if (vulnerabilities.length === 0) return 0;
  
  const totalScore = vulnerabilities.reduce((sum, vuln) => {
    return sum + getSeverityScore(vuln.severity);
  }, 0);
  
  return Math.min(100, Math.round((totalScore / vulnerabilities.length) * 10));
};